"""
Customer wanted to easily order items from automann.com based on purchase orders generated by PTM Vision.
PTM Vision saves data into Visual FoxPro tables.
Automann.com allows a cart to be filled using a csv file.
Either PTM Vision or Visual FoxPro denote a deleted item with Z*

This script queries the file po.dbf for all non-deleted items that haven't been ordered and are from the vendor ATM.
Sorts that data by part number, then creates a csv file in the format

part_number,qty_required

There are some weird edge cases where items with negative quantities can show up in the po file. After uploading the
file to Automann, the site will question you about such oddities.
"""


# I use this to easily keep production and testing separate.
from commonly_used_files import get_po
import csv
import dbf


def create_csv_for_automann_dot_com():
    def sort_list(list_to_sort):
        return_list = sorted(list_to_sort, key=lambda d: d['Partno'])
        return return_list

    def list_of_dict_to_csv(list_of_dict, file_to_use=r'C:\Users\User\Desktop\automann.csv'):
        list_of_dict_sorted = sort_list(list_of_dict)
        fieldnames = ['Partno', 'Qty']
        with open(file_to_use, 'w+', newline="", encoding='ascii') as csv_file:
            writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
            writer.writerows(list_of_dict_sorted)

        return file_to_use

    def get_items_from_pos(po_table):
        return_list = []

        items = po_table.query(f"select partno, qty where vendor.strip() == 'ATM' and\
            ordered != 'Y' and po.strip() != '*Z' and partno.strip() != '*Z'")

        for item in items:
            holder = {
                'Partno': item['Partno'].strip(),
                'Qty': item['Qty']
            }

            return_list.append(holder)

        return_list_sorted_by_part_number = sorted(return_list, key=lambda i: i['Partno'])

        return return_list_sorted_by_part_number

    def start():
        # I use this to easily keep production and testing separate.
        time_for_production = True
        po_file = get_po(time_for_production)
        po_table = dbf.Table(po_file, ignore_memos=True).open(mode=dbf.READ_ONLY)

        items_to_order = get_items_from_pos(po_table)

        file_to_use = list_of_dict_to_csv(items_to_order)

        po_table.close()

        return file_to_use

    file_to_use = start()

    return file_to_use
